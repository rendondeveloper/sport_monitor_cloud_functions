---
description: Reglas para desarrollo de Cloud Functions
alwaysApply: true
---

# Reglas para Cloud Functions - Firebase

## üìã Principios Fundamentales

### 1. Validaci√≥n Obligatoria
**TODAS** las Cloud Functions deben usar:
- `validate_request()` - Para validar CORS y m√©todo HTTP
- `verify_bearer_token()` - Para autenticaci√≥n

### 2. Respuestas Directas (Sin Wrappers)
**NUNCA** usar wrappers como `success`, `message`, `data` en respuestas exitosas.

**‚úÖ CORRECTO:**
```python
# Respuesta de cat√°logo
return https_fn.Response(
    json.dumps([
        {"label": "uno"},
        {"label": "dos"}
    ], ensure_ascii=False),
    status=200,
    headers={
        "Content-Type": "application/json; charset=utf-8",
        "Access-Control-Allow-Origin": "*",
    },
)

# Respuesta de objeto √∫nico
return https_fn.Response(
    json.dumps({
        "id": "123",
        "name": "Ejemplo"
    }, ensure_ascii=False),
    status=200,
    headers={
        "Content-Type": "application/json; charset=utf-8",
        "Access-Control-Allow-Origin": "*",
    },
)
```

**‚ùå INCORRECTO:**
```python
# NO usar wrappers
return https_fn.Response(
    json.dumps({
        "success": True,
        "message": "Operaci√≥n exitosa",
        "data": [...]
    }, ensure_ascii=False),
    status=200,
)
```

### 3. Errores con C√≥digos HTTP Apropiados
Los errores deben retornar **solo el c√≥digo HTTP** sin cuerpo JSON (excepto casos espec√≠ficos).

**‚úÖ CORRECTO:**
```python
# Error 400 - Bad Request
return https_fn.Response(
    "",
    status=400,
    headers={"Access-Control-Allow-Origin": "*"},
)

# Error 401 - Unauthorized
return https_fn.Response(
    "",
    status=401,
    headers={"Access-Control-Allow-Origin": "*"},
)

# Error 404 - Not Found
return https_fn.Response(
    "",
    status=404,
    headers={"Access-Control-Allow-Origin": "*"},
)

# Error 500 - Internal Server Error
return https_fn.Response(
    "",
    status=500,
    headers={"Access-Control-Allow-Origin": "*"},
)
```

**‚ùå INCORRECTO:**
```python
# NO retornar JSON en errores
return https_fn.Response(
    json.dumps({
        "success": False,
        "error": "Mensaje de error"
    }, ensure_ascii=False),
    status=400,
)
```

### 4. Patr√≥n Early Return
**SIEMPRE** usar Early Return para validaciones y errores. Esto mejora la legibilidad y reduce anidaci√≥n.

**‚úÖ CORRECTO:**
```python
@https_fn.on_request()
def my_function(req: https_fn.Request) -> https_fn.Response:
    # Validar CORS y m√©todo HTTP
    validation_response = validate_request(
        req, ["GET"], "my_function", return_json_error=False
    )
    if validation_response is not None:
        return validation_response

    try:
        # Validar Bearer token
        if not verify_bearer_token(req, "my_function"):
            logging.warning("my_function: Token inv√°lido o faltante")
            return https_fn.Response(
                "",
                status=401,
                headers={"Access-Control-Allow-Origin": "*"},
            )

        # Validar par√°metros
        param = req.args.get("param")
        if not param or param.strip() == "":
            logging.warning("my_function: Par√°metro faltante")
            return https_fn.Response(
                "",
                status=400,
                headers={"Access-Control-Allow-Origin": "*"},
            )

        # L√≥gica principal
        # ... c√≥digo de la funci√≥n ...

        # Retornar respuesta exitosa (JSON directo)
        return https_fn.Response(
            json.dumps(result, ensure_ascii=False),
            status=200,
            headers={
                "Content-Type": "application/json; charset=utf-8",
                "Access-Control-Allow-Origin": "*",
            },
        )

    except ValueError as e:
        logging.error("my_function: Error de validaci√≥n: %s", e)
        return https_fn.Response(
            "",
            status=400,
            headers={"Access-Control-Allow-Origin": "*"},
        )
    except (AttributeError, KeyError, RuntimeError, TypeError) as e:
        logging.error("my_function: Error interno: %s", e, exc_info=True)
        return https_fn.Response(
            "",
            status=500,
            headers={"Access-Control-Allow-Origin": "*"},
        )
```

**‚ùå INCORRECTO (sin Early Return):**
```python
@https_fn.on_request()
def my_function(req: https_fn.Request) -> https_fn.Response:
    validation_response = validate_request(...)
    if validation_response is None:
        if verify_bearer_token(req, "my_function"):
            param = req.args.get("param")
            if param and param.strip() != "":
                # L√≥gica anidada...
                return response
            else:
                return error_response
        else:
            return error_response
    else:
        return validation_response
```

## üèóÔ∏è Estructura de una Cloud Function

### Template Base

```python
import json
import logging
from typing import Any, Dict, List

from firebase_admin import firestore
from firebase_functions import https_fn
from models.firestore_collections import FirestoreCollections
from utils.helper_http import verify_bearer_token
from utils.helper_http_verb import validate_request


@https_fn.on_request()
def function_name(req: https_fn.Request) -> https_fn.Response:
    """
    Descripci√≥n de la funci√≥n.

    Headers:
    - Authorization: Bearer {Firebase Auth Token} (requerido)

    Par√°metros:
    - param1: Descripci√≥n (requerido)
    - param2: Descripci√≥n (opcional)

    Returns:
    - 200: JSON directo con los datos
    - 400: Bad Request - par√°metros faltantes o inv√°lidos
    - 401: Unauthorized - token inv√°lido o faltante
    - 404: Not Found - recurso no encontrado
    - 500: Internal Server Error
    """
    # 1. Validar CORS y m√©todo HTTP (OBLIGATORIO)
    validation_response = validate_request(
        req, ["GET"], "function_name", return_json_error=False
    )
    if validation_response is not None:
        return validation_response

    try:
        # 2. Validar Bearer token (OBLIGATORIO)
        if not verify_bearer_token(req, "function_name"):
            logging.warning("function_name: Token inv√°lido o faltante")
            return https_fn.Response(
                "",
                status=401,
                headers={"Access-Control-Allow-Origin": "*"},
            )

        # 3. Validar par√°metros (Early Return)
        param1 = req.args.get("param1")
        if not param1 or param1.strip() == "":
            logging.warning("function_name: param1 faltante o vac√≠o")
            return https_fn.Response(
                "",
                status=400,
                headers={"Access-Control-Allow-Origin": "*"},
            )

        # 4. L√≥gica principal
        db = firestore.client()
        # ... c√≥digo de la funci√≥n ...

        # 5. Retornar respuesta exitosa (JSON directo, sin wrapper)
        return https_fn.Response(
            json.dumps(result, ensure_ascii=False),
            status=200,
            headers={
                "Content-Type": "application/json; charset=utf-8",
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "GET, OPTIONS",
                "Access-Control-Allow-Headers": "Content-Type, Authorization",
            },
        )

    except ValueError as e:
        logging.error("function_name: Error de validaci√≥n: %s", e)
        return https_fn.Response(
            "",
            status=400,
            headers={"Access-Control-Allow-Origin": "*"},
        )
    except (AttributeError, KeyError, RuntimeError, TypeError) as e:
        logging.error("function_name: Error interno: %s", e, exc_info=True)
        return https_fn.Response(
            "",
            status=500,
            headers={"Access-Control-Allow-Origin": "*"},
        )
```

## üìù Ejemplos por Tipo de Respuesta

### 1. Respuesta de Array (Cat√°logo/Lista)

```python
# Obtener lista de categor√≠as
@https_fn.on_request()
def get_categories(req: https_fn.Request) -> https_fn.Response:
    validation_response = validate_request(
        req, ["GET"], "get_categories", return_json_error=False
    )
    if validation_response is not None:
        return validation_response

    try:
        if not verify_bearer_token(req, "get_categories"):
            logging.warning("get_categories: Token inv√°lido o faltante")
            return https_fn.Response(
                "",
                status=401,
                headers={"Access-Control-Allow-Origin": "*"},
            )

        # L√≥gica para obtener categor√≠as
        categories = [
            {"id": "1", "label": "Categor√≠a 1"},
            {"id": "2", "label": "Categor√≠a 2"},
        ]

        # Retornar array directo
        return https_fn.Response(
            json.dumps(categories, ensure_ascii=False),
            status=200,
            headers={
                "Content-Type": "application/json; charset=utf-8",
                "Access-Control-Allow-Origin": "*",
            },
        )

    except Exception as e:
        logging.error("get_categories: Error: %s", e, exc_info=True)
        return https_fn.Response(
            "",
            status=500,
            headers={"Access-Control-Allow-Origin": "*"},
        )
```

### 2. Respuesta de Objeto √önico

```python
# Obtener detalle de un recurso
@https_fn.on_request()
def get_resource_detail(req: https_fn.Request) -> https_fn.Response:
    validation_response = validate_request(
        req, ["GET"], "get_resource_detail", return_json_error=False
    )
    if validation_response is not None:
        return validation_response

    try:
        if not verify_bearer_token(req, "get_resource_detail"):
            logging.warning("get_resource_detail: Token inv√°lido o faltante")
            return https_fn.Response(
                "",
                status=401,
                headers={"Access-Control-Allow-Origin": "*"},
            )

        resource_id = req.args.get("resourceId")
        if not resource_id or resource_id.strip() == "":
            logging.warning("get_resource_detail: resourceId faltante")
            return https_fn.Response(
                "",
                status=400,
                headers={"Access-Control-Allow-Origin": "*"},
            )

        # L√≥gica para obtener recurso
        resource = {
            "id": resource_id,
            "name": "Nombre del Recurso",
            "description": "Descripci√≥n",
        }

        # Retornar objeto directo
        return https_fn.Response(
            json.dumps(resource, ensure_ascii=False),
            status=200,
            headers={
                "Content-Type": "application/json; charset=utf-8",
                "Access-Control-Allow-Origin": "*",
            },
        )

    except Exception as e:
        logging.error("get_resource_detail: Error: %s", e, exc_info=True)
        return https_fn.Response(
            "",
            status=500,
            headers={"Access-Control-Allow-Origin": "*"},
        )
```

### 3. Respuesta de Array Vac√≠o

```python
# Si no hay datos, retornar array vac√≠o
if not items:
    return https_fn.Response(
        json.dumps([], ensure_ascii=False),
        status=200,
        headers={
            "Content-Type": "application/json; charset=utf-8",
            "Access-Control-Allow-Origin": "*",
        },
    )
```

### 4. Respuesta 404 (Recurso No Encontrado)

```python
# Verificar existencia del recurso
resource_doc = db.collection("resources").document(resource_id).get()
if not resource_doc.exists:
    logging.warning("get_resource: Recurso no encontrado: %s", resource_id)
    return https_fn.Response(
        "",
        status=404,
        headers={"Access-Control-Allow-Origin": "*"},
    )
```

## üîç Validaciones Comunes

### Validaci√≥n de Par√°metros Query

```python
# Validar par√°metro requerido
param = req.args.get("param")
if not param or param.strip() == "":
    logging.warning("function_name: param faltante o vac√≠o")
    return https_fn.Response(
        "",
        status=400,
        headers={"Access-Control-Allow-Origin": "*"},
    )
```

### Validaci√≥n de Request Body (POST/PUT)

```python
# Parsear request body
try:
    request_data = req.get_json(silent=True)
    if request_data is None:
        logging.warning("function_name: Request body inv√°lido o faltante")
        return https_fn.Response(
            "",
            status=400,
            headers={"Access-Control-Allow-Origin": "*"},
        )
except (ValueError, TypeError) as e:
    logging.warning("function_name: Error parseando JSON: %s", e)
    return https_fn.Response(
        "",
        status=400,
        headers={"Access-Control-Allow-Origin": "*"},
    )

# Validar campos requeridos
required_fields = ["field1", "field2"]
missing_fields = [f for f in required_fields if f not in request_data]
if missing_fields:
    logging.warning("function_name: Campos faltantes: %s", missing_fields)
    return https_fn.Response(
        "",
        status=400,
        headers={"Access-Control-Allow-Origin": "*"},
    )
```

### Validaci√≥n de Tipos

```python
# Validar que un campo sea un n√∫mero
try:
    order = int(request_data.get("order"))
    if order < 0:
        raise ValueError("order debe ser positivo")
except (ValueError, TypeError):
    logging.warning("function_name: order inv√°lido")
    return https_fn.Response(
        "",
        status=400,
        headers={"Access-Control-Allow-Origin": "*"},
    )
```

## üéØ Aislamiento de Tareas

### Separar L√≥gica en Funciones Auxiliares

**‚úÖ CORRECTO:**
```python
def _get_competitors_from_firestore(db, event_id, day_of_race_id):
    """Obtiene competidores desde Firestore."""
    tracking_id = f"{event_id}_{day_of_race_id}"
    competitors_ref = (
        db.collection(FirestoreCollections.EVENT_TRACKING)
        .document(event_id)
        .collection(FirestoreCollections.EVENT_TRACKING_COMPETITOR_TRACKING)
        .document(tracking_id)
        .collection(FirestoreCollections.EVENT_TRACKING_COMPETITOR)
    )
    return competitors_ref.get()


def _build_competitor_dict(competitor_doc):
    """Construye diccionario de competidor."""
    competitor_data = competitor_doc.to_dict()
    return {
        "id": competitor_doc.id,
        "name": competitor_data.get("name", ""),
        "order": competitor_data.get("order", 0),
    }


@https_fn.on_request()
def get_competitors(req: https_fn.Request) -> https_fn.Response:
    # Validaciones...
    
    db = firestore.client()
    competitors_snapshot = _get_competitors_from_firestore(db, event_id, day_of_race_id)
    
    result = [
        _build_competitor_dict(doc) 
        for doc in competitors_snapshot
    ]
    
    return https_fn.Response(
        json.dumps(result, ensure_ascii=False),
        status=200,
        headers={
            "Content-Type": "application/json; charset=utf-8",
            "Access-Control-Allow-Origin": "*",
        },
    )
```

**‚ùå INCORRECTO (todo en una funci√≥n):**
```python
@https_fn.on_request()
def get_competitors(req: https_fn.Request) -> https_fn.Response:
    # Validaciones...
    
    # Todo el c√≥digo mezclado
    db = firestore.client()
    tracking_id = f"{event_id}_{day_of_race_id}"
    competitors_ref = (
        db.collection(FirestoreCollections.EVENT_TRACKING)
        .document(event_id)
        .collection(FirestoreCollections.EVENT_TRACKING_COMPETITOR_TRACKING)
        .document(tracking_id)
        .collection(FirestoreCollections.EVENT_TRACKING_COMPETITOR)
    )
    competitors_snapshot = competitors_ref.get()
    
    result = []
    for doc in competitors_snapshot:
        competitor_data = doc.to_dict()
        result.append({
            "id": doc.id,
            "name": competitor_data.get("name", ""),
            "order": competitor_data.get("order", 0),
        })
    
    return https_fn.Response(...)
```

## üìã Checklist de Implementaci√≥n

Antes de crear una Cloud Function, verificar:

- [ ] ‚úÖ Usa `validate_request()` para validar CORS y m√©todo HTTP
- [ ] ‚úÖ Usa `verify_bearer_token()` para autenticaci√≥n
- [ ] ‚úÖ Respuesta exitosa retorna JSON directo (sin wrappers)
- [ ] ‚úÖ Errores retornan solo c√≥digo HTTP (sin JSON)
- [ ] ‚úÖ Usa patr√≥n Early Return para validaciones
- [ ] ‚úÖ L√≥gica separada en funciones auxiliares
- [ ] ‚úÖ Logging apropiado para errores y warnings
- [ ] ‚úÖ Headers CORS correctos
- [ ] ‚úÖ Manejo de excepciones con try/except
- [ ] ‚úÖ Validaci√≥n de par√°metros con Early Return
- [ ] ‚úÖ Documentaci√≥n en docstring
- [ ] ‚úÖ Usa constantes de `FirestoreCollections` (no strings hardcodeados)
- [ ] ‚úÖ Si necesita nueva colecci√≥n, la agreg√≥ a `FirestoreCollections` antes de usarla

### Checklist Post-Implementaci√≥n

Despu√©s de crear y desplegar una Cloud Function, verificar:

- [ ] ‚úÖ Funci√≥n documentada completamente en `README.md`
- [ ] ‚úÖ Endpoint URL documentado (directo y con hosting)
- [ ] ‚úÖ Par√°metros documentados (query, path, body)
- [ ] ‚úÖ Ejemplos de cURL incluidos en README
- [ ] ‚úÖ Respuestas documentadas (√©xito y errores)
- [ ] ‚úÖ Funci√≥n agregada a lista de funciones con autenticaci√≥n en README
- [ ] ‚úÖ Comando de deploy agregado en secci√≥n de despliegue del README
- [ ] ‚úÖ Estructura del proyecto actualizada en README si es necesario

## üö´ Errores Comunes a Evitar

### ‚ùå NO hacer esto:

1. **Usar wrappers en respuestas exitosas:**
   ```python
   # ‚ùå INCORRECTO
   return json.dumps({"success": True, "data": result})
   ```

2. **Retornar JSON en errores:**
   ```python
   # ‚ùå INCORRECTO
   return json.dumps({"error": "Mensaje"}, status=400)
   ```

3. **Anidar validaciones:**
   ```python
   # ‚ùå INCORRECTO
   if condition1:
       if condition2:
           if condition3:
               # c√≥digo
   ```

4. **Mezclar l√≥gica en la funci√≥n principal:**
   ```python
   # ‚ùå INCORRECTO
   @https_fn.on_request()
   def my_function(req):
       # 200 l√≠neas de c√≥digo mezclado
   ```

5. **Olvidar validar token:**
   ```python
   # ‚ùå INCORRECTO
   @https_fn.on_request()
   def my_function(req):
       # No valida token
       return result
   ```

## üìö Referencias

- `utils/helper_http.py` - Funci√≥n `verify_bearer_token()`
- `utils/helper_http_verb.py` - Funci√≥n `validate_request()`
- `models/firestore_collections.py` - Constantes de colecciones

## üóÑÔ∏è Uso de FirestoreCollections

### Regla Obligatoria: Usar Constantes de FirestoreCollections

**SIEMPRE** usar las constantes del archivo `FirestoreCollections` en lugar de strings hardcodeados.

**‚úÖ CORRECTO:**
```python
from models.firestore_collections import FirestoreCollections

# Usar constantes
event_ref = db.collection(FirestoreCollections.EVENTS).document(event_id)
categories_ref = event_ref.collection(FirestoreCollections.EVENT_CATEGORIES)
vehicles_ref = user_ref.collection(FirestoreCollections.USER_VEHICLES)
```

**‚ùå INCORRECTO:**
```python
# NO usar strings hardcodeados
event_ref = db.collection("events").document(event_id)
categories_ref = event_ref.collection("event_categories")
vehicles_ref = user_ref.collection("vehicles")
```

### Agregar Nuevas Colecciones

**SIEMPRE** que se necesite una nueva colecci√≥n de Firestore que no existe en `FirestoreCollections`, agregarla al archivo antes de usarla.

**Proceso:**
1. Abrir `functions/models/firestore_collections.py`
2. Identificar la secci√≥n apropiada (colecciones principales, de eventos, de usuarios, de tracking, etc.)
3. Agregar la constante siguiendo el formato existente
4. Usar la constante en la Cloud Function

**Ejemplo:**
```python
# En FirestoreCollections
class FirestoreCollections:
    # Colecciones principales
    EVENTS = "events"
    USERS = "users"
    
    # Colecciones de usuarios relacionados
    USER_VEHICLES = "vehicles"  # ‚Üê Nueva colecci√≥n agregada
    USER_PROFILE = "profile"
```

**Ubicaci√≥n del archivo:** `functions/models/firestore_collections.py`

## üìñ Documentaci√≥n en README

### Regla Obligatoria: Documentar Endpoints en README

**SIEMPRE** que se finalice la creaci√≥n de un endpoint (Cloud Function), agregar su documentaci√≥n completa al archivo `README.md`.

**Proceso de Documentaci√≥n:**

1. **Identificar la secci√≥n apropiada** en el README seg√∫n el package:
   - Package `events` ‚Üí Secci√≥n "üì¶ Package: Events"
   - Package `users` ‚Üí Secci√≥n "üì¶ Package: Users"
   - Package `checkpoints` ‚Üí Secci√≥n "üì¶ Package: Checkpoints"
   - Package `vehicles` ‚Üí Secci√≥n "üì¶ Package: Vehicles" (crear si no existe)
   - Package `tracking` ‚Üí Secci√≥n "üì¶ Package: Tracking"

2. **Agregar documentaci√≥n completa** con:
   - Descripci√≥n de la funci√≥n
   - Tipo de request (GET, POST, PUT, DELETE)
   - Endpoint URL (directo y con hosting)
   - Headers requeridos
   - Par√°metros (query, path, body)
   - Campos retornados
   - Ejemplos de comandos cURL
   - Respuestas exitosas y de error
   - Notas importantes

3. **Actualizar secciones relacionadas:**
   - Agregar funci√≥n a la lista de funciones que requieren autenticaci√≥n
   - Agregar comando de deploy en la secci√≥n de despliegue
   - Actualizar estructura del proyecto si es necesario

**Ejemplo de estructura en README:**

```markdown
## üì¶ Package: Vehicles

Funciones relacionadas con la gesti√≥n de veh√≠culos de competidores.

### X. `function_name`

Descripci√≥n breve de la funci√≥n.

**Tipo**: HTTP Request (GET/POST/PUT/DELETE)  
**Endpoint**: `https://function-name-xa26lpxdea-uc.a.run.app`  
**Endpoint con Hosting**: `https://system-track-monitor.web.app/api/vehicles/...`

**Nota**: Esta funci√≥n requiere autenticaci√≥n Bearer token.

#### Headers Requeridos
...

#### Par√°metros
...

#### Campos Retornados
...

#### Comandos cURL
...

#### Respuestas
...
```

**Ubicaci√≥n del archivo:** `README.md` en la ra√≠z del proyecto

**Checklist de Documentaci√≥n:**
- [ ] Funci√≥n documentada en la secci√≥n apropiada del README
- [ ] Endpoint URL documentado (directo y con hosting)
- [ ] Par√°metros documentados (query, path, body)
- [ ] Ejemplos de cURL incluidos
- [ ] Respuestas documentadas (√©xito y errores)
- [ ] Funci√≥n agregada a lista de funciones con autenticaci√≥n
- [ ] Comando de deploy agregado en secci√≥n de despliegue
- [ ] Estructura del proyecto actualizada si es necesario

## ‚úÖ Resumen de Reglas

1. **SIEMPRE** usar `validate_request()` y `verify_bearer_token()`
2. **NUNCA** usar wrappers (`success`, `message`) en respuestas exitosas
3. **SIEMPRE** retornar solo c√≥digo HTTP en errores (sin JSON)
4. **SIEMPRE** usar Early Return para validaciones
5. **SIEMPRE** separar l√≥gica en funciones auxiliares
6. **SIEMPRE** usar logging para errores y warnings
7. **SIEMPRE** incluir headers CORS apropiados
8. **SIEMPRE** usar constantes de `FirestoreCollections` (nunca strings hardcodeados)
9. **SIEMPRE** agregar nuevas colecciones a `FirestoreCollections` antes de usarlas
10. **SIEMPRE** documentar endpoints completos en `README.md` al finalizar su creaci√≥n
